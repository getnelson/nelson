<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="canonical" href="https://getnelson.io/">

  <meta name="generator" content="Hugo 0.22.1" />

  <title>Nelson</title>

  
  

  <link href="https://netdna.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://getnelson.io/css/docs.min.css" rel="stylesheet">
  <link href="https://getnelson.io/css/style.css" rel="stylesheet">
  <link href="https://getnelson.io/css/style.blue.css" rel="stylesheet">

  <script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
  <script src="https://netdna.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bootbox.js/4.3.0/bootbox.min.js"></script>
  <script src="https://getnelson.io/js/docs.min.js"></script>
</head>

<body>

  
  <header class="navbar navbar-static-top bs-docs-nav" id="top">
  <div class="container">
    <div class="navbar-header" role="banner">
      <a class="navbar-brand" href="https://getnelson.io/">Nelson</a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        
        
        <li class="">
          <a href="/reference.html">Reference</a>
        </li>
        
        <li class="">
          <a href="/development.html">Development</a>
        </li>
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
        <li>
          <a href="https://github.com/getnelson/nelson">GitHub</a>
        </li>
        
        <li>
          <a href="https://getnelson.github.io/nelson/api/">API Docs</a>
        </li>
        
      </ul>
    </nav>
  </div>
</header>


  

  <div class="bs-docs-masthead" id="content">
    <div class="container">
      <h1 class="home-title">Nelson</h1>
      <p class="lead">Automated, multi-region container deployment</p>
      <p class="lead">
        <a href="//github.com/getnelson/nelson" class="btn btn-outline-inverse btn-lg">Source Code</a>
      </p>
      <p class="version">
        Currently v0.10.48<br />
      </p>
    </div>
    <a href="https://travis-ci.org/getnelson/nelson">
      <img src="https://travis-ci.org/getnelson/nelson.svg" />
    </a>
  </div>

  <div class="container bs-docs-container">
    <div class="row">
      
      <div class="col-md-9" role="main">
        <article class="post-content">

          
              <h1 id="overview" class="page-header">Overview</h1>

<p>Nelson is a fully automated deployment orchestration tool intended to work with a datacenter scheduling system, such as Hashicorp Nomad or Apache Mesos. Nelson is responsible for application lifecycle, traffic routing specification and providing fully automated security policy management.</p>

<h3 id="overview-philosophy" class="linkable">
  Philosophy
</h3>

<ul>
<li>Uniformity is highly desirable / advantageous.</li>
<li>As many aspects to deployments as possible should be automated.</li>
<li>Automated lifecycle management is key to providing a holistic, scalable solution.</li>
<li>Manual promotion to production is high-cost since the &ldquo;last-mile&rdquo; of release management can cause friction.</li>
<li>Nelson supports manual deployment for those not yet comfortable with continuous deployment processes).</li>
</ul>

<h3 id="overview-features" class="linkable">
  Features
</h3>

<ul>
<li>Fully integrated with GitHub or GitHub Enterprise.</li>
<li>Developer-driven, automated build &amp; release workflow revisioned as code.</li>
<li>Support for multiple cluster managers, including <a href="https://www.nomadproject.io/">Hashicorp Nomad</a>.</li>
<li>Compatible with any <a href="https://www.docker.com">Docker</a> container.</li>
<li>Can deploy applications to any number of datacenters.</li>
<li>State of the art runtime routing via <a href="https://lyft.github.io/envoy/">Envoy</a>.</li>
<li>Integrated support for alert definition and propagation via <a href="https://prometheus.io/">Prometheus</a>.</li>
<li>Utilizes secure introduction for safe distribution of credentials from <a href="https://www.vaultproject.io/">Vault</a>.</li>
</ul>

<h3 id="overview-workflow" class="linkable">
  Workflow
</h3>

<p>Nelson splits the build-&gt;deploy-&gt;release phases into two major parts, each with distinctly different properties. First, the building of the containers and publishing to a staging registry. Second, the deployment, validation, and migration of traffic. The following diagram illustrates a high-level view of the first major part of the workflow.</p>

<div class="clearing">
  <img src="images/high-level-workflow.png" />
  <small><em>Figure 1.0: workflow overview</em></small>
</div>

<p>There are a range of automated steps at every phase of the build and release pipeline. Nelson ensures that it is fetching what it needs from the tagged GitHub repository. Only the most minimal element of metadata generated in the resulting release is needed to conduct a deployment. Nelson is agnostic to what language your application is built with or how it is tooled.You are free to integrate however you prefer, but we provide some tools to make doing so easy.</p>

<h1 id="quickstart" class="page-header">Quickstart</h1>

<p>The QuickStart guide is a high level document intended to provide migrating users with essential information to successfully leverage Nelson for deployment.</p>

<p>As a user of Nelson, we are making a series of assumptions that impact the way the system is ultimately used (for operator-level concerns such as the installation, management and upgrading of a Nelson installation, please see <a href="#operator-guide">the operator guide</a>). Nelson users should have a working knowledge of the following:</p>

<ul>
<li>GitHub (Pull Requests, Git branches etc)</li>
<li>Docker (practical usage of, knowledge of the general workflow)</li>
<li>Usage of a terminal (assuming Darwin or Linux)</li>
</ul>

<p>It is strongly suggested you become familiar with these requirements before proceeding.</p>

<h2 id="quickstart-git" data-subheading-of="quickstart">Git-centric</h2>

<p>Everything must be versioned. Nelson adopts a hardline position on configuration and changes made to systems at runtime: with two explicit exceptions, no application shall change its operable configuration. This means that your configuration is code and should be checked in along with your application. This includes the declarative manifest file that Nelson uses to receive its instructions. If you need configuration changes, modify it, check it in and redeploy.</p>

<p>The two exceptions to this are:</p>

<ul>
<li><p><strong>Credential Distribution</strong>: the act of providing your application with credentials. This includes passwords for databases, SSL certificates and so forth. Credential distribution is discussed in the next section.</p></li>

<li><p><strong>Traffic Shifting</strong>: when deploying a service Nelson will move traffic from version <code>A</code> to version <code>B</code> at runtime, for any given system. Whilst this is not strictly &ldquo;part of the application&rdquo;, it is the only other aspect of a container that is changing at runtime. Everything else is immutable.</p></li>
</ul>

<p>Adopting this approach has several advantages:</p>

<ul>
<li><p>The output Docker images are essentially dumb and the registry does not need to be tightly secured, because no private information or system secrets are in the container a-priori.</p></li>

<li><p>Every single change to the system has an audit trail, thanks to Git.</p></li>

<li><p>Reduced deployment risk: by deploying smaller sets of changes more frequently, you can know exactly what change set went into a particular version. There are several development workflows available with Nelson (covered below), so you can choose your deployment cadence and the amount of code that goes into a specific release.</p></li>
</ul>

<p>Nelson does not support ad-hoc deployments. This is explicit and by-design. With this frame, Nelson works best in a poly-repo environment, where builds focus on small, atomic units. Nelson can work with explicit tagging and releasing for those with a mono-repo style of source control (more on this later).</p>

<h2 id="quickstart-credentials" data-subheading-of="quickstart">Credentials</h2>

<p>Nelson leverages secure introduction. This means that the container does not hold any secrets until the very moment it is launched, and that the credentials given to the container dictate the access permissions the container has. <strong>You cannot interact with a system or resource that you did not tell Nelson about</strong>, and we&rsquo;ll cover how you inform Nelson about your dependencies in the next section.</p>

<p>Practically speaking, credentials are sourced from <a href="https://www.vaultproject.io/">Vault</a>, and then mounted to a tempfs attached to the container. You can only source credentials from Vault, for which you have a valid Vault Policy. As it would turn out, these policies are dynamically generated by Nelson, and provisioned for you automatically. The credentials themselves should either be provisioned or configured by a member of staff with Vault access, and this should be done ahead of time, before you try to deploy your application with Nelson.</p>

<h2 id="quickstart-dependencies" data-subheading-of="quickstart">Dependencies</h2>

<p>Nearly all systems - services or jobs - have dependencies. Here are some examples:</p>

<ul>
<li>Databases</li>
<li>Message Queue</li>
<li>AWS S3</li>
<li>Third-party services (anything not deployed by Nelson)</li>
</ul>

<p>Within these dependencies resides several nuances. There are those dependencies which are deployed within the same datacenter infrastructure as your applications, and are internally provisioned. Other services, databases and message queues are the most common examples of dependencies.</p>

<p>There is a second category of dependencies, and these are broadly referred to as &ldquo;resources&rdquo;. These are systems that an application may require to run, but are &ldquo;external&rdquo; to the datacenter target. Typically these are systems that are global from the callers perspective - ones that have an opaque URL for the caller. Any public or third-party service operates in this manner. Concrete examples of resources include Amazon S3, Google search service etc.</p>

<h2 id="quickstart-ssh" data-subheading-of="quickstart">Zero Access</h2>

<p>When you deploy applications with Nelson, there&rsquo;s no SSH access. Period. Your application containers are deployed onto one or more target datacenter clusters. The operations staff who setup the cluster will have access to the host worker nodes, but the host only provides compute resources. Having access to the nodes themselves adds no additional value from a debugging perspective, as <strong>all monitoring and log data should be transferred out of the container</strong>.</p>

<h2 id="quickstart-consistency" data-subheading-of="quickstart">Consistency</h2>

<p>By virtue of the fact that <em>Nelson</em> is orchestrating application deployments over potentially many target datacenters, it is important to realize that there is a subsequent lack of transactionality in the operations <em>Nelson</em> takes. This is most apparent when deploying a new revision of a particular system: application code can never assume it is a &ldquo;singleton&rdquo; or in some way special, as the minimum number of versions running - even if it&rsquo;s for a very short time - will be greater than one. <em>Nelson</em> will eventually deliver on its promise and make one revision the primary revision of a system by cleaning up the others, depending on the particular circumstances, that process might not be immediate.</p>

<p>This means that application builders have the following constraints:</p>

<ol>
<li><p>Applications which require singleton behavior can either choose to implement application-layer leader election, or use convergent data structures to make sure that all overlapping changes will always commute.</p></li>

<li><p>Data corruption can - and will - eventually happen and applications need to be able to recover from this. Typically this means checkpointing data writes to limit the blast radius of any potential corruption (more appropriate for batch-style processes), engineering teams should properly evaluate the possibility for corruption and recovery in their particular use case.</p></li>
</ol>

<p>The authors of <em>Nelson</em> full appreciate that these constraints require more engineering work. However, by applying these constraints it means <em>Nelson</em> can provide a guarantee around several critical behaviors, and set the right expectation from the start about application lifecycle.</p>

<h1 id="user-guide" class="page-header">User Guide</h1>

<p>This user guide covers the information that a user should make themselves familiar with to both get started with Nelson, and also get the most out of the system. Certain parts of Nelson have been covered in more detail than would be typical for an entry-level user guide, but this is to make sure users are fully aware of the choices they are making when building out their deployment specification.</p>

<h2 id="user-guide-installation" data-subheading-of="user-guide">Installation</h2>

<p>The primary route for interacting with Nelson is via a command line client. The command line client provides most of the functionality the majority of users would want of Nelson. A future version of Nelson will also have a web-based user experience, which will have more statistical reporting functions and tools for auditing.</p>

<p>If you just want to use nelson-cli, then run the following to install it:</p>

<pre><code>curl -GqL https://raw.githubusercontent.com/Verizon/nelson-cli/master/scripts/install | bash
</code></pre>

<p>This script will download and install the latest version and put it on your <code>$PATH</code>. We do not endorse piping scripts from the wire to <code>bash</code>, and you should read the script before executing the command. It will:</p>

<ol>
<li>Fetch the latest version from Nexus</li>
<li>Verify the SHA1 sum</li>
<li>Extract the tarball</li>
<li>Copy nelson to <code>/usr/local/bin/nelson</code></li>
</ol>

<p>It is safe to rerun this script to keep nelson-cli current. Before getting started, ensure that you have followed these instructions the first time you install:</p>

<ol>
<li><a href="https://help.github.com/articles/creating-an-access-token-for-command-line-use/">Obtain a Github personal access token</a> - ensure your token has the following scopes: <br /> <code>repo:*</code>, <code>admin:read:org</code>, <code>admin:repo_hook:*</code>.</li>
<li>Set the Github token into your environment: <code>export GITHUB_TOKEN=XXXXXXXXXXXXXXXX</code></li>
<li><code>nelson login nelson.example.com</code>, then you&rsquo;re ready to start using the other commands! If you&rsquo;re running the Nelson service insecurely - without SSL - then you need to pass the <code>--disable-tls</code> flag to the login command.</li>
</ol>

<p>Then you&rsquo;re ready to use the CLI. The first command you should execute after install is <code>nelson login</code> which allows you to securely interact with the remote Nelson service.</p>

<div class="alert alert-warning" role="alert">
â›”&nbsp; Note that currently the Nelson client can only be logged into <strong>one</strong> remote <em>Nelson</em> service at a time.
</div>

<h2 id="user-guide-terminology" data-subheading-of="user-guide">Terminology</h2>

<p>In order to understand the rest of this user guide, there are a set of terms that are useful to understand:</p>

<table class="table table-striped">
  <thead>
    <tr>
      <td width="15%"><strong>Term</strong></td>
      <td><strong>Description</strong></td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><em>Repository</em></td>
      <td>References one source code repository: this may contain multiple unit kinds, but represents one canonical release workflow (i.e. all units in the repository are updated and released together).</td>
    </tr>
    <tr>
      <td><em>Scheduler</em></td>
      <td>The element within the datacenter that actually makes work placement decisioning, based upon the available resources (e.g. CPU, RAM etc).</td>
    </tr>
    <tr>
      <td><em>Datacenter</em></td>
      <td>Represents a single failure domain - it is a <em>logical</em> ascription of some computing resources to which work can be assigned. In practice, a "datacenter" from Nelson's perspective may either be a single <code>scheduler</code> endpoint that directly maps to a single physical datacenter (which internally has redundant power domains), or it could be multiple virtual datacenters within a geographic region (e.g. AWS Availability Zone). The key thing is that Nelson's concept of datacenter is all about scheduling failure modes.</td>
    </tr>
    <tr>
      <td><em>Namespace</em></td>
      <td>Defines a virtual space for units to operate. One namespace cannot talk to a unit in another namespace. The namespace itself represents a collection of units. More often than not, these namespaces take names such as "dev", "qa" and "production". While it is common to think of these as environments, this term was specifically avoided because it typically carries with it the idea of physical separation, which does not exist in a shared computing environment.</td>
    </tr>
    <tr>
      <td><em>Plan</em></td>
      <td>Defines how a unit is to be deployed. It specifies the resource requirements, constraints, and environment variables.</td>
    </tr>
    <tr>
      <td><em>Unit</em></td>
      <td>Defines logically what is to be deployed. Units pertain specifically to the concept of something that is deployable at the high level. For example, one could have a unit <code>accounts</code> or <code>api-gateway</code>. Units are not versioned, and do not discriminate between how they are deployed, i.e. as a service (long lived and not expected to terminate) or job.</td>
    </tr>
    <tr>
      <td><em>Stack Name</em></td>
      <td>Whilst units are a logical concept only, stacks are the direct implementations of units. Specifically, a stack represents a unique deployment of a very particular unit, of a particular version number, along with a uniquely provisioned hash. For example: <code>accounts--2-8-287--roiac45o</code>.</td>
    </tr>
    <tr>
      <td><em>Feature Version</em></td>
      <td>Feature versions are the first two <code>major</code> and <code>minor</code> digits of a <a href="http://semver.org/" target="_blank">semantic version number</a>. Feature versions are always of the form <code>X.Y</code>, for example: <code>1.2</code>, <code>4.6</code> etc.</td>
    </tr>
  </tbody>
</table>

<h2 id="user-guide-cleanup" data-subheading-of="user-guide">Lifecycle</h2>

<p>Every stack that gets deployed using Nelson is living on borrowed time. Everything will be removed at some point in the future, as the deployment environment &ldquo;churns&rdquo; with new versions, and older versions are phased out over time. This principle is baked into Nelson, as every single stack has an associated expiry time. With this in mind, each and every stack moves through a variety of states during its lifetime. The figure below details these states:</p>

<div class="clearing">
  <img src="images/stack-states.png" />
  <small><em>Figure 2.0: stack states</em></small>
</div>

<p>At first glance this appears overwhelming, as there are many states. Some of these states will be temporary for your particular stack deployment, but nonetheless, this is the complete picture. The following table enumerates the states and their associated transitions:</p>

<table class="table table-striped">
  <thead>
    <tr>
      <td><strong>From</strong></td>
      <td><strong>To</strong></td>
      <td><strong>Description</strong></td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>pending</code></td>
      <td><code>deploying</code></td>
      <td>Internally, Nelson queues workflow execution, and if the maximum number of workflows are currently executing it will buffer tasks in memory until resources are available to execute the requested workflow. Once the workflow starts executing the stack will move into the <code>deploying</code> state.</td>
    </tr>
    <tr>
      <td><code>deploying</code></td>
      <td><code>failed</code></td>
      <td>In the event the workflow being executed fails for some reason - whatever the cause - the workflow moves the stack into the <code>failed</code> state so that Nelson knows that this stack did not get to a healthy point in its lifecycle, and is pending proper termination.</td>
    </tr>
    <tr>
      <td><code>deploying</code></td>
      <td><code>warming</code></td>
      <td>Once a stack gets started by Nelson, there is an optional chance to send synthetic traffic to the deployed stack to warm the process. This is common in JVM-based systems, where the JIT needs warming before production traffic is rolled onto the deployment, otherwise users may notice perceptible latency in request handling for entirely technical reasons. This state is optional, and the manner in which its implemented is entirely workflow dependent.</td>
    </tr>
    <tr>
      <td><code>warming</code></td>
      <td><code>ready</code></td>
      <td>Once warmed (if applicable) the deployment moves into the <code>ready</code> state. This is the steady state for any given stack, regardless of unit type, and regardless of the operational health of a system (from a monitoring perspective), Nelson will perceive the stack as logically ready.</td>
    </tr>
    <tr>
      <td><code>ready</code></td>
      <td><code>deprecated</code></td>
      <td>Over time, a particular development team for a given system might want to phase out an older version of their system, for some technical reason (e.g. in order to make a completely incompatible API change or upgrade user data in a backward compatible manner). In order to do this a development team will first need to ensure that all consumers of their API have moved to a newer version. Nelson provides the concept of "deprecation" to do this - a deprecated service cannot be depended on by subsequent deployments, once it has been marked as deprecated. Systems that were already deployed will continue to use the deprecated service until such time as they themselves are phased out and upgraded with newer stacks. </td>
    </tr>
    <tr>
      <td><code>ready</code></td>
      <td><code>garbage</code></td>
      <td>Over time different services may be refactored and altered in a variety of ways. This can often lead to orphaned service versions that just waste resources on the cluster, so to avoid this Nelson actively figures out what stacks depend on what other stacks, and transitions stacks to the <code>garbage</code> state if nobody is calling that stack.</td>
    </tr>
    <tr>
      <td><code>deprecated</code></td>
      <td><code>garbage</code></td>
      <td>Once no other stack depends on the deprecated stack, it will move to the <code>garbage</code> state.</td>
    </tr>
    <tr>
      <td><code>garbage</code></td>
      <td><code>terminated</code></td>
      <td>For any stack that is residing in the garbage state, there is a grace period of 24hrs for which that stack will be left running, and after the grace period the garbage is taken out and stacks are fully terminated and removed from the cluster. Terminated stacks are entirely stopped and consume zero resources on the cluster.</td>
    </tr>
  </tbody>
</table>

<h3 id="user-guide-lifecycle-warming" class="linkable">Warming Grace</h3>

<p>When a system is newly deployed, it is very common that an application will require a certain grace period to warm up. For example, an application may need time to heat up internal caches which could take several minutes. Alternatively it might just take a while for the application to fully initialize and bind to the appropriate ports. Whatever the case, Nelson provides every application stack a grace period where they are immune from any kind of cleanup for 30 minutes after being deployed. This grace period duration is 30 minutes by default, and is configured via the Nelson configuration <code>nelson.cleanup.initial-deployment-time-to-live</code> Knobs property.</p>

<p>In order to understand if an application has fully warmed up or not, Nelson relies on the healthcheck statuses in Consul to indicate what the current status of a newly deploy application is. Units that have ports declared in their manifest are expected to expose a TCP service bound on that port. The healthchecks are a simplistic L4 probe and are specified by Nelson when launching your application onto the scheduler. If these probes do not report passing healthchecks after the initial grace window, your application will be garbage collected. An unhealthy application cannot have traffic routed to it, and serves no useful purpose in the wider runtime.</p>

<p>If you expose ports, you <strong>must</strong> bind them with something. Nelson controls the cadence in which it checks stack states with Consul via the <code>nelson.readiness-delay</code>, which is intervals of 3 minutes by default.</p>

<h3 id="user-guide-lifecycle-gc" class="linkable">Garbage Collection</h3>

<p>A key part of application lifecycle is the ability to cleanup application stacks that are no longer needed. Users can specify an <code>expiration_policy</code> for any Nelson <code>unit</code>, and whilst these policies provide a variety of semantics (detailed below), there&rsquo;s a common decision tree executed to figure out which policy to apply and when. Figure 2.1 details this algorithm:</p>

<div class="clearing">
  <img src="images/cleanup.png" width="55%" />
  <small><em>Figure 2.1: cleanup decision tree</em></small>
</div>

<p>In practice the &ldquo;Evaluate Policy&rdquo; decision block is one of the following policies - which can be selected by the user. The first and most common policy is <code>retain-active</code>. This is the default for any unit that exposes one or more network ports.</p>

<p>Nelson has an understanding of the entire logical topology for the whole system. As such, Nelson is able to make interesting assertions about what is - and is not - still required to be running. In the event that a new application (<code>F 1.3</code> in the diagram) is deployed which no longer requires its previous dependency <code>G 1.0</code>, both <code>F 1.1</code> and <code>G 1.0</code> are declared unnecessary garbage, and scheduled for removal.</p>

<div class="clearing">
  <img src="images/dependencies-upgrade.png" width="40%" />
  <small><em>Figure 2.2: retain active</em></small>
</div>

<p>Where <code>retain-active</code> shines is that its exceedingly automatic: all the while another application needs your service(s), Nelson will keep it running and automatically manage the traffic shifting to any revisions that might come along.</p>

<p>A somewhat similar but more aggressive strategy is <code>retain-latest</code>. Whilst this may appear similar to <code>retain-active</code>, <code>retain-latest</code> will <em>always</em> tear down everything except the latest revision of an application. Typically this tends to be useful for jobs (spark streaming or spark batch for example) but it is exceedingly dangerous for services that evolve over time, as <code>retain-latest</code> forces all your users up to the very latest revision, when they could well not be ready for a breaking API change (e.g. 1.0 vs 2.0).</p>

<div class="clearing">
  <img src="images/cleanup-policies-retain-latest.png" width="60%" />
  <small><em>Figure 2.3: retain two major versions</em></small>
</div>

<p>A more moderate policy for jobs would be <code>retain-latest-two-major</code> or <code>retain-latest-two-feature</code>. These policies allow you to keep existing versions of your code operational, whilst adding new versions.</p>

<div class="clearing">
  <img src="images/cleanup-policies-two-feature.png" width="60%" />
  <small><em>Figure 2.4: retain latest two feature versions</em></small>
</div>

<p>These policies are typically used for jobs where you want to actively compare and contrast two different types of output (the one you&rsquo;re currently using vs the next - a typical function in analyzing ML model evolution).</p>

<div class="clearing">
  <img src="images/cleanup-policies-two-major.png" width="60%" />
  <small><em>Figure 2.5: retain latest two major versions</em></small>
</div>

<p>Cleanup policies in Nelson can be explored with <code>nelson system cleanup-policies</code> from the CLI. If you believe there are additional use cases not covered by the default policies, please <a href="#community">enter the community</a> and let us know what you think is missing.</p>

<p>Any time Nelson executes or actions a cleanup policy - or inaction causes a state transition - it will be recorded in the <a href="#install-auditing">auditing system</a>, so you can be aware of exactly what Nelson did on your behalf.</p>

<h2 id="user-guide-manifest" data-subheading-of="user-guide">Manifest</h2>

<p>One of the core tenets of the Nelson philosophy is that all changes are checked into source code - nothing should be actioned out of band, in an entirely untrackable manner. Nelson requires users define a manifest file and check it into the root of the repository. This file is called <code>.nelson.yml</code> (note the preceding <code>.</code> since it is a UNIX dotfile). This file contains the application <code>unit</code> definitions, along with any additional configuration for monitoring, alerting and scaling those units. Consider a simple example that launches a Hello World service:</p>

<pre><code class="language-yaml">---
units:
  - name: hello-world
    description: &gt;
      very simple example service that says
      hello world when the index resource is
      called via http
    ports:
      - default-&gt;9000/http

plans:
  - name: default

namespaces:
  - name: dev
    units:
      - ref: hello-world
      - plans:
         - default
</code></pre>

<p>This is the simplest <code>.nelson.yml</code> that one could define for a unit that exposes a service on port 9000. It declares a unit called <code>hello-world</code>, and then exposes a port. This is an example of a unit that is typically referred to as a service. By comparison, units that are intended to be run periodically define a <code>schedule</code>. Such a unit is typically referred to as a job. Below is a simple example of a unit that is run hourly:</p>

<pre><code class="language-yaml">---
units:
- name: hello-world
  description: &gt;
    very simple example job that prints
    hello world and exits right away

plans:
- name: dev-plan
  schedule: hourly

namespaces:
- name: dev
  units:
  - ref: howdy
    plans:
    - dev-plan
</code></pre>

<p>Here the two units are similar, but the second defines a <code>schedule</code> under the plans stanza, which indicates that the unit is to be run periodically as a <code>job</code>.</p>

<p>The manifest contains a variety of settings and options too numerous to mention in this introductory text. Suggested further reading <a href="reference.html#manifest">in the reference</a> about the Nelson manifest answers the following common queries:</p>

<ul>
<li>How do I declare a dependency on another unit?</li>
<li>How do I get alerted when my unit has a problem at runtime?</li>
<li>How do I expose my service to the outside world?</li>
</ul>

<p>Now that you have your <code>.nelson.yml</code> as you want it, add the file to the <strong>root</strong> of your source repository, and commit it to the <code>master</code> branch. Nelson will look at the repositories&rsquo; <code>master</code> branch when it first attempts to validate your repository is something that is Nelson-compatible. You can check the validity of your manifest definition at anytime without checking in by using the Nelson CLI: <code>nelson lint manifest</code>.</p>

<h2 id="user-guide-deployables" data-subheading-of="user-guide">Deployables</h2>

<p>A Nelson-enabled repository signals a deployment to Nelson by making a <a href="https://help.github.com/articles/about-releases/">release</a>. This release serves two purposes: to ensure versioning so that the code and deployment history can be traced through GitHub, and to inform Nelson which units to deploy for that release. Where the manifest enumerates all the units and plans under the repository&rsquo;s purview, the deployables attached to a release tell Nelson which units to actually deploy for that release.</p>

<p>Specifically, manifests describe a logical definition (e.g. a unit name) and deployables tie that logical definition to a physical one (e.g. a specific Docker image). This prevents the need to update the manifest everytime a version is bumped (frequent in a continuous delivery setting), whilst avoiding the need for a mutable tag like <code>latest</code>.</p>

<p>The <a href="https://github.com/getnelson/slipway">Slipway</a> tool can help with both creating a deployable file as well as making the actual annotated release. It is available as a <a href="https://github.com/getnelson/slipway/releases">small statically linked binary</a> ready to be pulled and used in a CI pipeline.</p>

<p>If you&rsquo;d like, the deployable file format is pretty simple and can be created without Slipway. Each file should be named as <code>&lt;unit name&gt;.deployable.yml</code> and look like:</p>

<pre><code class="language-yaml">---
name: &lt;unit name&gt;
version: &lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;
output:
  kind: docker
  image: &lt;docker image&gt;
</code></pre>

<p>The unit name and version in the file name and contents is what Nelson enters into its database - therefore the unit name in the filename should match the unit name in the contents which should match a unit name in the manifest. Because Nelson is version-aware, the same logical version cannot be deployed twice - the version must be incremented, though not necessarily sequential, with each new release.</p>

<p>The Docker image tag typically matches the version, but it doesn&rsquo;t have to. Note that the provided Docker image is assumed to exist by the time the release (and therefore the deployment) is made, likely built and pushed by an earlier step in the CI pipeline. Nelson does little with the image string other than forward it to the backing scheduler.</p>

<p>As an example, consider a manifest that contains <code>foo</code>, <code>bar</code>, and <code>baz</code> as units. To tell Nelson to deploy <code>foo</code> and <code>bar</code> for a release, something similar to the following would be attached to the release (likely with Slipway):</p>

<p>In <code>foo.deployable.yml</code>:</p>

<pre><code class="language-yaml">---
name: foo
version: 1.2.3
output:
  kind: docker
  image: your.docker.com/repo/foo:1.2.0
</code></pre>

<p>In <code>bar.deployable.yml</code>:</p>

<pre><code class="language-yaml">---
name: bar
version: 2.1.3
output:
  kind: docker
  image: your.docker.com/repo/bar:2.1.3
</code></pre>

<h2 id="user-guide-credentials" data-subheading-of="user-guide">Credentials</h2>

<p>Nelson fully supports building systems that are secure-by-default. This is specifically enabled by support for secure introduction. Every unit that gets deployed via Nelson are granted a token that allows them to read from <a href="https://www.vaultproject.io/docs">Vault</a>, which is the credential management system integrated with Nelson. For a primer on Vault, please <a href="https://www.vaultproject.io/intro/">see the dedicated documentation site</a>.</p>

<p>For users, the recommended approach to gain credential access is to provide explicit details to your system administration / operations team about the credential you want access too. That team will then create the necessary configuration in the Vault backend. Subsequent deployments after those credentials are provisioned will allow you to access Vault and read the relevant credential (e.g. database password, certificate etc).</p>

<div class="alert alert-warning" role="alert">
  If your credential has not been provisioned access in Vault, then your container will not have access to the credentials you are expecting. It is <strong>highly</strong> recommended that your application does a sanity check for its credentials during the boot / initialization phase and in the event those required credentials are not present, the application moves into a relevant failure mode. This might be to terminate itself, or to suspend its bootup until the correct credentials are provisioned. Either way, this state should be logged or reported via monitoring.
</div>

<p>With this frame, any information you require at runtime that is sensitive, or is non-public must be provided via <a href="https://github.com/hashicorp/consul-template">consul template</a>. As it turns out, requiring runtime details (credentials, for example) is very common, so let&rsquo;s consider an example in which we want to render a small <a href="http://verizon.github.io/knobs/">Knobs</a> configuration file that we can include to get our database credentials. To do this, we&rsquo;ll need to make a template in your project, that once rendered will put the populated configuration file inside the container at <code>/opt/application/conf/runtime.cfg</code>. This document assumes you have consul-template running inside your container image and Nomad is being used as the scheduler (to leverage secure introduction):</p>

<pre><code>{{with $ns := env &quot;NELSON_ENV&quot;}}
{{with secret (print &quot;nelson/&quot; $ns &quot;/test/creds/howdy-http&quot;)}}
db.password = {{ $secret.Data.password }}
{{end}}
{{end}}
</code></pre>

<p>Here, the path being used in the <code>vault</code> stanza would be provided to users from the operations team after submitting a request for credentials. Whilst this path is static, Vault will either dynamically provision credentials for your calling application, or read a set of securely stored values from the generic mount.</p>

<h2 id="user-guide-enabling-deployment" data-subheading-of="user-guide">Enable Nelson</h2>

<p>With your repository in good shape, you&rsquo;re ready to enable Nelson to deploy your project whenever it sees a new release. To do this, visit the URL where Nelson is deployed, and login using your Github. Upon doing this for the first time, you will see the following prompt (or something similar, for your account):</p>

<div class="clearing">
  <img src="images/enable-nelson-github.png" />
  <small><em>Figure 2.1: approve github access page</em></small>
</div>

<p>Once authorized, you will be redirected to the Nelson home page which provides instructions on how to get started with the Nelson CLI. You can enable a repository for deployment by using the <code>nelson repos enable</code> command:</p>

<pre><code># list the repositories for a given user or organization
nelson repos list -o githubuser

# enable one of those repositories for deployment
nelson repos enable -o githubuser -r githubrepo
</code></pre>

<p>If for some reason you cannot enable your repository, the CLI should inform you why that is. In order to enable deployment for a given repository, you need to ensure that you have a valid <code>.nelson.yml</code> manifest file checked in, which passes <code>nelson lint manifest</code>. Invalid manifest files cannot be read by Nelson, and therefore cannot be deployed.</p>

<h2 id="user-guide-routing" data-subheading-of="user-guide">Routing</h2>

<p>Nelson supports a dynamic discovery system, which leverages semantic versioning and control input from manifest declarations to make routing choices. This part of the system is perhaps one of the most complicated elements, so a brief overview is included here, and specific details can be found within the <a href="reference.html#routing">reference section</a>. To give a general overview, figure 3.1 highlights the various moving parts.</p>

<div class="clearing">
  <img src="images/routing-design.png" height="70%" />
  <small><em>Figure 3.1: container routing</em></small>
</div>

<p>Reviewing the figure, the runtime workflow works as follows:</p>

<p>A. The container is launched by the scheduler and consul-template interacts with a consul agent running on the surrounding host. Consul Template obtains a certificate from the PKI backend in Vault after negotiating with its secure Vault token.</p>

<p>B. Envoy boots using the certificates obtained from the first step, and then looks for <code>consort.service</code> in the local consul domain. Consort acts as a mediator between data stored in Consul and the protocol that Envoy uses for both SDS (converting stack names into IPs) and CDS (discovering the list of stacks). Envoy periodically reaches out to Consort to perform SDS and CDS, but never does so in the runtime hot-path.</p>

<p>C. Application boots and goes about its business. In the event the application is attempting to make a call to another service, it actually calls to &ldquo;localhost&rdquo; from the containers perspective, and hits the locally running Envoy instance. Envoy then wraps the request in mutual SSL and forwards it to the target service instance. In this way, the application itself is free from knowing about the details of mutual authentication and certificate chains. All calls made via Envoy are automatically circuit-broken and report metrics via StatsD. This is rolled up to a central StatsD server.</p>

<h2 id="user-guide-lbs" data-subheading-of="user-guide">Load Balancers</h2>

<p>In addition to service to service routing, Nelson also supports routing traffic into the runtime via &ldquo;load balancers&rdquo; (LBs). Nelson treats these as a logical concept, and supports multiple backend implementations; this means that if Nelson has one datacenter in AWS, it knows about <a href="https://aws.amazon.com/elasticloadbalancing/">ELB</a> and so forth. If however, you have another datacenter not on a public cloud, Nelson can have alternative backends that do the needful to configure your datacenter for external traffic. The workflow at a high-level is depicted in figure 3.2.</p>

<div class="clearing">
  <img src="images/lbs.png" height="70%" />
  <small><em>Figure 3.2: load balancer overview</em></small>
</div>

<p>Typically load balancers are static at the edge of the network because external DNS is often mapped to them. This is clearly a mismatch between statically configured DNS and the very dynamic, scheduler-based infrastructure Nelson otherwise relies upon. To bridge this gap, Nelson makes the assumption that the LB in question is capable of dynamically updating its runtime routes via consuming the Lighthouse discovery protocol.</p>

<p>Nelson also publishes static configuration pertaining the load balancer before it&rsquo;s launched into the datacenter.</p>

<p>The protocol is as follows and is published to Consul&rsquo;s KV store at nelson/v1/loadbalancers/<lb-name>:</p>

<pre><code>[
  {
    &quot;port_label&quot;: &quot;default&quot;,
    &quot;frontend_port&quot;: 8444,
    &quot;service_name&quot;: &quot;http-service&quot;,
    &quot;major_version&quot;: 1
  }
]
</code></pre>

<p>Whilst the fields should be self-explanatory, here are a list of definitions:</p>

<table class="table table-striped">
  <thead>
    <tr>
      <td><strong>field</strong></td>
      <td><strong>description</strong></td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>port_label</code></td>
      <td>Port label used to describe this particular port in the manifest definition. All ports require a named label.</td>
    </tr>
    <tr>
      <td><code>frontend_port</code></td>
      <td>Port used to expose traffic on the outside of the load balancer. The available ports are restricted by the configuration parameter <code>proxy-port-whitelist</code>.</td>
    </tr>
    <tr>
      <td><code>service_name</code></td>
      <td>The service to route traffic to.</td>
    </tr>
    <tr>
      <td><code>major_version</code></td>
      <td>The major version the load balancer is bound to. Note, a load balancer's life cycle is bound the the major version of the service it is proxying</td>
    </tr>
  </tbody>
</table>

<h3 id="user-guide-lbs-manifest" class="linkable">Usage</h3>

<p>Providing the manifest definition for LBs is very similar to that of the unit definitions. Consider the following example:</p>

<pre><code>loadbalancers:
  - name: foo-lb
    routes:
      - name: foo
        expose: default-&gt;8444/http
        destination: foobar-&gt;default
      - name: bar
        expose: monitoring-&gt;8441/https
        destination: foobar-&gt;monitoring
</code></pre>

<p>Load balancers have their own top-level block in the manifest, as they are not strictly unit types and form their own special constraints (see <a href="#user-guide-lbs-cleanup">cleanup</a> for more on that). The key part here is the <code>routes</code> block, which allows users to expose inbound routes (using the same syntax as <code>unit</code> port declarations), along with a <code>destination</code> that allows you to declare which internal system this LB depends on, and which labeled port on the downstream system should be routed too. By using these labels and not explicit ports, the LB and the downstream unit are not tightly coupled; service expose a logical set of functionality on a port, and the load balancer always routes to that functionality - based the label - even if it changes ports in the future.</p>

<h3 id="user-guide-lbs-cleanup" class="linkable">Cleanup</h3>

<div class="alert alert-warning" role="alert">
  <strong>IMPORTANT</strong> If you create a load balancer - and no longer need it - you are responsible for cleaning it up.
</div>

<p>With Nelson using its internal routing graph to calculate cleanup actions for the deployed systems, the load balancers act as a form of anchor for the wider system. In practice, this means that LBs form the caller for other service on the graph, which prevents those services from being cleaned up because they have inbound traffic from Nelson&rsquo;s perspective. Due to this, Nelson is not able to cleanup LBs because its general policy application cannot work - LBs are the edge of the world.</p>

<p>In the event that the downstream systems are cleaned up forcefully by hand, users must be sure to also remove the LBs to conserve resources (external IPs are, for example, a finite resource). This is particularly relevant if you are operating on a public cloud where the LB cluster would continue to cost you money.</p>

<h3 id="user-guide-lbs-aws" class="linkable">Amazon Web Services</h3>

<p>When using Nelson with a datacenter located in AWS, the system has to work within a set of constraints to meet the aforementioned dynamic versioning ability for downstream routing destinations. In order to achieve this, the &ldquo;load balancer&rdquo; on AWS looks like:</p>

<div class="clearing">
  <img src="images/lbs-aws.png" height="70%" />
  <small><em>Figure 3.3: load balancer on AWS</em></small>
</div>

<p>The proxy implementation itself should typically be a large container that is run in host networking mode, but implementors are free to bake whatever AMI they see fit for this component. Provided the implementor consumes the Nelson LB protocol from Consul, Nelson won&rsquo;t care how the LB is implemented.</p>

<h3 id="user-guide-lbs-alternatives" class="linkable">Alternative Implementations</h3>

<p>At the time of writing only the AWS load balancers were natively supported. Supporting additional modes of load balancing is straightforward but left as an exercise for the reader. Looking toward the future it probally would make sense for Nelson to support the prominant cloud providers natively, but that work is not currently in the roadmap.</p>

<h2 id="user-guide-troubleshooting" data-subheading-of="user-guide">Troubleshooting</h2>

<p>If you added your <code>.nelson.yml</code> file to your repository <code>master</code> branch, and manifest validation is passing and you&rsquo;re chugging along making GitHub releases, then you will want to know what Nelson is doing with your repo, right? Well, the Nelson CLI has a set of useful utilities into what happened with your project deployments. First, you would want to list the datacenters available on your instance of Nelson:</p>

<pre><code>nelson datacenters list
</code></pre>

<p>This will give you the list of datacenters that Nelson knows about and the namespaces available in each. For the sake of this document, lets assume the name of the datacenter is <code>texas</code>. Now we know <em>where</em> our deployment might be, we can ask Nelson to display all the things it deployed into that location:</p>

<pre><code>nelson stacks list -d texas -ns dev
</code></pre>

<p>Here, we&rsquo;re asking for the <code>dev</code> namespace, but use whatever is applicable for your particular enquiry. All being well, if your application was launched you should see it in the list. If however, your application does not appear to be in the list then its possible there was some kind of problem, so we need to ask Nelson to tell us about things it deployed which <code>failed</code> or were <code>terminated</code>:</p>

<pre><code>nelson stacks list -d texas -ns dev -s failed,terminated
</code></pre>

<p>If Nelson failed to deploy your stack for a technical reason, it should appear on this list. If you would like to know what the specific error is you can inspect the Nelson stack logs like so:</p>

<pre><code># where XXXXXX is the GUID from the `stacks list` command above.
nelson stacks logs XXXXXX
</code></pre>

<p>This should tell you exactly what Nelson did with your deployment. Every step in the workflow is logged to the workflow logger; the log shows literally everything Nelson did on your behalf. If the logs do not show any particular errors, then you might want to ask the runtime what the current state of play is, which can be done with the <code>runtime</code> command:</p>

<pre><code>nelson stacks runtime XXXXXX
</code></pre>

<p>Nelson will return a summary response from the scheduler about what state the stack is <em>currently</em> in. In the event the runtime says that your stack is <code>pending</code> this means the requested datacenter scheduler is still looking for resources to satisfy your request.</p>

<h1 id="operator-guide" class="page-header">Operator Guide</h1>

<p>Nelson is typically deployed on-premises and should be co-located with network line of sight with either <code>github.com</code> or a GitHub Enterprise instance; wherever you are storing your source code.
Nelson itself deploys as a docker container, so can be deployed pretty much anywhere, regardless of if its on bare metal with a <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">systemd unit</a>, or on a cloud container service like <a href="https://aws.amazon.com/ec2/">AWS EC2</a> or <a href="https://cloud.google.com/container-engine/">GCE</a>. It is important to note that Nelson itself is explicitly designed to <strong>not be high availability</strong>. Every subsystem that Nelson talks to (Consul, Vault, etc) is redundant within the target datacenter. In the event that Nelson is offline, the only impact is that your users cannot deploy for a short period until service is restored. The runtime is fully resilient to a Nelson outage.</p>

<h2 id="installation" data-subheading-of="operator-guide">Installation</h2>

<p>Installing Nelson is composed of several steps:</p>

<ol>
<li><a href="#installation-machine">Checking machine requirements</a></li>
<li><a href="#installation-github">Adding the Github application</a></li>
<li><a href="#installation-configuration">Configuring Nelson</a></li>
<li><a href="#installation-launching">Running Nelson</a></li>
</ol>

<h3 id="installation-machine" class="linkable">Machine Requirements</h3>

<p>Nelson has reasonably small runtime requirements, as it is a lightweight process. Nelson is typically consuming CPU and memory resources for its background tasks, and uses local disk storage as a scratch space whilst replicating containers to a remote registries in the target datacenter(s). With this in mind, the following machine specifications are recommended:</p>

<ul>
<li>8-16GB of RAM</li>
<li>100GB of disk space (preferably SSDs)</li>
<li>Ubuntu 16.04</li>
</ul>

<p>It is strongly advised to <strong>not</strong> use a RedHat-based OS for running Nelson. After a great deal of testing, Debian-based OS has been found to be orders of magnitude faster at running Docker than RedHat counterparts. This seems to be related to the interplay of the I/O subsystems, but the author was unable to find a clear &ldquo;smoking gun&rdquo; for this huge delta in performance. If users would like to use Red Hat, please reach out to the Nelson team for operational advice.</p>

<h3 id="installation-github" class="linkable">Authorize with Github</h3>

<p>Nelson is implemented as a Github OAuth application, and it requires a one-time setup when installing it into your Github organization. If you are not familiar with how to setup a Github application, please see the <a href="https://developer.github.com/guides/basics-of-authentication/">GitHub documentation site</a> for details. This process should work equally well on both <a href="https://github.com">github.com</a> and Github Enterprise.</p>

<p>When registering Nelson with Github, the exact domain on which the Nelson process is reachable should be specified (take care select the right protocol - <code>http</code> vs <code>https</code>), and the callback URL should be: <code>https://your.nelson.domain.net/auth/exchange</code>. From a networking standpoint, provided the Github instance can reach the Nelson server, and the domain specified in the OAuth application matches that being used by the client, then the system should work. <strong>If you are using <code>github.com</code>, then your Nelson instance must be accessible from the Github outbound NAT address</strong>. If you encounter problems during the setup, the Nelson logs should contain information about the error.</p>

<p>Once setup, Github will present you with a <code>client_id</code> and a <code>client_secret</code> for the application. These are needed by the Nelson configuration, along with a system OAuth token Nelson can use to execute asynchronous actions on the applications behalf (i.e. without direct user interaction). Run the following to generate the access token:</p>

<pre><code>curl -s https://raw.githubusercontent.com/Verizon/nelson/master/bin/generate-token | bash
</code></pre>

<p>If you have the Nelson source checked out locally on your development machine, then you can run <code>./bin/generate-token</code> if you would rather not pipe scripts from the internet to bash. The script will ask you a series of questions, and produce a OAuth token. This token - along with the <code>client_id</code> and <code>client_secret</code> - needs to be set in the Nelson configuration file like so:</p>

<pre><code>nelson{
  github {
    client-id = &quot;XXXXXXX&quot;
    client-secret = &quot;YYYYYYYYYY&quot;
    redirect-uri = &quot;http://nelson.yourcompany.com/auth/exchange&quot;
    access-token = &quot;TOKEN-FROM-SCRIPT&quot;
  }
}
</code></pre>

<p>Please see the <a href="#instalation-configuration">configuration section</a> for details on where and how the Nelson configuration is loaded.</p>

<h3 id="installation-configuration" class="linkable">Configuration</h3>

<p>Nelson has a range of configuration options specified using the <a href="https://verizon.github.io/knobs/">Knobs</a> format, read from fils on disk. Nelson can either be told where to load configuration from, but if no path is specified then it will assume that it should be loaded from <code>/opt/application/conf/nelson.cfg</code>.</p>

<p>Many of the Nelson defaults will be fine for the majority of users. There are however, several configuration sections which must be updated by the operator to ensure Nelson works as expected. Here&rsquo;s an example of the minimal configuration file:</p>

<pre><code>nelson {
  network {
    # Typically Nelson is hosted behind a reverse proxy, or otherwise bound
    # to an internal address. In order for cookie retention to work for browsers,
    # and for Nelson to rewrite its generated URLs to locations that are
    # network accessible, the operator must tell Nelson what that external address is.
    external-host = &quot;nelson.yourco.com&quot;
  }
  github {
    # If you're operating Nelson in conjunction with Github Enterprise, then you
    # need to be sure you've set this value to the host (without protocol prefix).
    # For example &lt;code&gt;github.yourco.com&lt;/code&gt;
    domain = &quot;github.yourco.com&quot;
    # The client_id and client_secret provided to you from Github, whilst
    # setting up the application. See the &quot;Authorize with Github&quot; section for more
    # on the paramaters below:
    client-id = &quot;XXXXXXX&quot;
    client-secret = &quot;YYYYYYYYYY&quot;
    redirect-uri = &quot;http://nelson.yourcompany.com/auth/exchange&quot;
    access-token = &quot;TOKEN-FROM-SCRIPT&quot;
    # Certain operations in Nelson make serious state modifications, and as such
    # these are restricted to a specific set of &quot;admin&quot; users. The operator must
    # specifiy these users at boot time. Changing these values whilst Nelson is
    # running will have absolutely no effect (i.e. the process must be rebooted
    # for changes to take effect)
    organization-admins = [ &quot;user1&quot;, &quot;user2&quot; ]
  }
  security {
    # These keys are used to securely encrypt the Nelson session token that are
    # generated when a user logs into the system. The keys themselves must be
    # at least 24 characters long. A helpful script in ./bin/generate-keys can
    # be used to automatically generate the right values.
    # *****DO NOT USE THESE VALUES*****
    encryption-key = &quot;4e08LjzM42El6+Gbfp9XaQ==&quot;
    signature-key = &quot;ZRq3NkqbccXE7+ZkRirjOg==&quot;
  }
  docker {
    # Decide how you would like Nelson to attempt to interact with Docker.
    # This is typically done either by a unix domain socket, or via a tcp
    # endpoint. Nelson itself is controling docker via the CLI, so it will
    # use whatever the configuration is for a given host.
    connection = &quot;unix:///path/to/docker.sock&quot;
    # connection = &quot;tcp://0.0.0.0:12345&quot;
  }

  datacenters {
    # The name of this key must be a DNS value name. Typically you want to call your
    # datacenters something logical, but keep it short. AWS for example, uses
    # us-east-1, us-west-1 etc.
    # Datacenter names must be lowercase, and not include specical characters.
    texas {

      docker-registry = &quot;sxxxx.net/bar&quot;

      # this is the DNS domain used for a given datacenter. When writing out the lighthouse
      # routing graph or similar, Nelson will use this value as the TLD for a given datacenter
      # &quot;world&quot;. An assumption is being made here that you're running DNS fowrading for
      # the consul service: https://www.consul.io/docs/guides/forwarding.html
      domain = &quot;service.example.com&quot;

      # What should the default traffic shifting policy be in this particular DC.
      # Configurable per-DC such that you might have production DCs, vs dev DCs
      # (of course remember DC is a virtual concept)
      traffic-shift {
        policy = &quot;atomic&quot;
        duration = 2 minute
      }

      infrastructure {
        scheduler {
          scheduler = &quot;nomad&quot;
          nomad {
            # Where can Nelson access the Nomad leader cluster
            endpoint  = &quot;https://nomad.service&quot;
            # How much grace shall we give when talking to Nomad.
            # Depending upon your link speed (e.g. if you're tunneling via SSH or
            # IPSEC it might be slower)
            timeout   = 1 second
            # On average, how many MHz of CPU does each node in this datacenter have?
            # This is used to compute the `cores` convenience in the Nelson manifest;
            # its typically better to under-specify this value, rather than over-specify
            # in the event you have a mixed fleet of machines.
            mhz-per-cpu = 2300
            # location of the runtime Docker registry. Optionally, if you require auth
            # for pushing or pulling from this registry, specify it here.
            # NOTE: Nomad does not currently encrypt these values in its `nomad inspect`
            # functionality, so be aware that unless you have a secure API access to
            # nomad, then users might see these values.
            docker {
              user = &quot;randal mcmurphy&quot;
              password = &quot;one flew&quot;
              host = &quot;registery.service.whatever.com&quot;
            }
          }
        }
        consul {
          # Location of the consul service in this datacenter.
          endpoint  = &quot;https://consul.service.whatever.com&quot;
          # How much grace shall we give when talking to Consul.
          # Depending upon your link speed (e.g. if you're tunneling via SSH or
          # IPSEC it might be slower)
          timeout   = 1 second
          # Nelson will be writing to the KV store in Consul, so be sure to have
          # an appropriate ACL token set here if required for read or write operations.
          acl-token = &quot;...&quot;
        }
        vault {
          endpoint = &quot;https://vault.california.service&quot;
          # How much grace shall we give when talking to Vault.
          # Depending upon your link speed (e.g. if you're tunneling via SSH or
          # IPSEC it might be slower)
          timeout   = 1 second
          # Nelson will be administering Vault, creating policies and such. With this
          # in mind, you need to ensure that Nelson has a vault authentication token
          # which permits these operations.
          auth-token = &quot;...&quot;
        }
      }
      policy {
        # When Nelson manages policies and credential stores in Vault, where should
        # it assume it can find them. This simplistic substitution syntax allows you
        # to control how Nelson will read and write to and from Vault storage paths.
        resource-creds-path = &quot;nelson/%env/%resource%/creds/%unit%&quot;
        # If you have Vault configured to generate SSL certificates, then in order for
        # deployed containers to be able to generate these certs at runtime, you need
        # to have Nelosn include that backend in the policy it generates. If you have
        # a global PKI backend called &quot;sslpki&quot;, then you can statically set the
        # backend like this:
        # pki-path = &quot;sslpki&quot;
        # In the event you have a dynamic &quot;per-environment&quot; SSL security world, then
        # this simple substitution language allows you to tell Nelson how it should
        # discover the PKI backend path in vault.
        pki-path = &quot;%env%_certificates&quot;
      }
    }
  }
}
</code></pre>

<p>The following table gives an explanation of the configuration file sections and their purpose, but for a full explanation and all available configuration options please see <a href="https://github.com/verizon/nelson/blob/master/core/src/main/resources/nelson/defaults.cfg">defaults.cfg</a> in the source tree.</p>

<table class="table table-striped">
  <thead>
    <tr>
      <td><strong>Section</strong></td>
      <td><strong>Description</strong></td>
    </tr>
  </thead>
  <tr>
    <td><code>nelson.network</code></td>
    <td>Specifiy the networking options used by Nelson, including the network interface the JVM binds too, port binding, and the address Nelson advertises in its API</td>
  </tr>
  <tr>
    <td><code>nelson.security</code></td>
    <td>Control the encryption keys used by Nelson for session token encryption, token signing and expiration.</td>
  </tr>
    <tr>
    <td><code>nelson.github</code></td>
    <td>Most installations will absolutely have to configure this section, as the OAuth application identifiers are different for every setup. Whilst Nelson will typically execute actions on Github with the credentials of the active session, this section also allows you to configure a "nelson user" for your Github integration that Nelson will use to interact with Github asynchronously, for non-user invoked actions. In future this will be replaced by deriving an OAuth token on startup from the configured Nelson OAuth application.</td>
  </tr>
    <tr>
    <td><code>nelson.docker</code></td>
    <td>Instructs Nelson how it should connect to the docker daemon it should use for replicating containers to the remote datacenter. Typically this is in the style of `unix:///path/to/socket` or `tcp://127.0.0.1:5678`.</td>
  </tr>
    <tr>
    <td><code>nelson.database</code></td>
    <td>Configure the JDBC connection string Nelson will use. Typically this is not configured by users.</td>
  </tr>
    <tr>
    <td><code>nelson.timeout</code></td>
    <td>Global timeout Nelson should apply for I/O operations to its dependent systems (Github, Nomad etc)</td>
  </tr>
    <tr>
    <td><code>nelson.cleanup</code></td>
    <td>Controls the grace periods Nelson gives to new applications, and the size of the bump period when extending expirations. Fields of particular user interest here are `initial-deployment-time-to-live` and `extend-deployment-time-to-live`.</td>
  </tr>
  <tr>
    <td><code>nelson.pipeline</code></td>
    <td>Whilst typically not edited by users, these settings control the amount of back-pressure in the Nelson deployment pipeline, and the level of concurrency Nelson uses when doing deployments. Altering these values from the default requires taking into account the latency and network I/O limitations of the host, as more concurrency will mean concurrent replication of containers (which is typically limited by docker defaults, unless overridden by a specific installation).</td>
  </tr>
  <tr>
    <td><code>nelson.template</code></td>
    <td>When using the <a href="https://github.com/hashicorp/consul-template" target="_blank">consul-template</a> linting feature, this block must be configured. The defaults are usually fine for the majority of users.</td>
  </tr>
  <tr>
    <td><code>nelson.workflow-logger</code></td>
    <td>Typically not altered by users, but these settings control where and how the workflow logger stores the execution logs for a given deployment. These end up being small text files on disk, and the buffer size controls how frequently the queue is flushed to the file writing process.</td>
  </tr>
  <tr>
    <td><code>nelson.email</code></td>
    <td>If you wish to configure Nelson with email notifications of job status, then you must configure this section with valid SMTP details for an email relay that Nelson can access.</td>
  </tr>
    <tr>
    <td><code>nelson.slack</code></td>
    <td>Nelson can notify you about deployment actions via Slack. For this integration to work a slack team admin must generate a Slack webhook URL and have Nelson configured to use this value.</td>
  </tr>
    <tr>
    <td><code>nelson.datacenters.YOURDC</code></td>
    <td>Various subsections that configure the credentials and endpoints for your scheduler implementation, consul, vault etc.</td>
  </tr>
    <tr>
    <td><code>nelson.ui</code></td>
    <td>Nelson ships with a bare-bones UI to support login via Github. You can however easily override the UI and supply whatever interface you want, utilizing the Nelson REST interface.</td>
  </tr>
    <tr>
    <td><code>nelson.nomad</code></td>
    <td>Some static configuration properties for using Nomad. For example, `required-service-tags` are additional identifiers that Nelson will attach to the Consul service catalog entry, allowing you identify workloads from any other records in the service catalog (typically exceedingly useful for monitoring or migration auditing)</td>
  </tr>
    <tr>
    <td><code>nelson.readiness-delay</code></td>
    <td>When a unit exposing ports is deployed, how frequently should Nelson check if the consul health checks have transitioned to "healthy". Nelson requires a majority of container instances to be reporting healthy in consul before transitioning the stack state from <code>Warming</code> to <code>Ready </code></td>
  </tr>
    <tr>
    <td><code>nelson.discovery-delay</code></td>
    <td>The cadence that Nelson should recompute the runtime routing graph and update the consul values for a specific stack. The more stacks you have, the longer this work will take so be sure to set the value here at an appropriate rate relevant to your deployment size. Be aware that the longer this delay is, the more "choppy" your short-duration traffic bleeds will be (this typically isn't an issue, as short-duration traffic shifting is discouraged as it can result in inbound traffic synfloods.).</td>
  </tr>
  <tr>
    <td><code>nelson.lb-port-whitelist</code></td>
    <td>Control the "outside" ports you want to allow users to expose from load balancers. Typically it is undesirable to have end-users be able to expose any random port at the edge of your network, as this can drastically increase security attack surface and make security auditing challenging. Instead, set a known set of ports that are agreed accross teams that will be used for external traffic ingress.</td>
  </tr>
   <tr>
    <td><code>nelson.manifest-filename</code></td>
    <td>By default, Nelson will look for a `.nelson.yml` file in the root of a repository, but if you'd prefer to use a different file for some reason then just tell Nelson what that filename should be here.</td>
  </tr>
  <tr>
    <td><code>nelson.default-namespace</code></td>
    <td>Upon receiving a github release event, where should Nelson assume the application should get deployed too. This can either be a root namespace, or a subordinate namespace, e.g. `stage/unstable`... its arbitrary, but the namespace must exist (Nelson will attempt to create the specified namespace on bootup).</td>
  </tr>
</table>

<p>This table should be considered an overview, and not an exhaustive list of the configuration options Nelson exposes. The author does not expect most users to be altering the default values for the majority of fields, but know that these values exist.</p>

<h3 id="installation-launching" class="linkable">Launching Container</h3>

<p>Typically Nelson is operated and installed as a <code>systemd</code> unit, but users are free to configure or operate the system however they please (<code>initV</code>, <code>upstart</code> etc). The docker command you use to start the system should look something like the following:</p>

<pre><code>docker run -it --rm \
  --name nelson \
  -p 9000:9000 \
  -p 5775:5775 \
  -v &quot;/etc/nelson/nelson.cfg&quot;:/opt/application/conf/nelson.cfg \
  -v &quot;/var/nelson/db&quot;:/opt/application/db \
  -v &quot;/var/nelson/log&quot;:/var/nelson/log \
  verizon/nelson:latest
</code></pre>

<p>This command - or a command like it - can be run from any system with docker, and the file mounts supplied (using <code>-v</code>) are used so that the Nelson database and related configuration files are stored on the host system, and not within the container. This allows Nelson to persist state over process reboots.</p>

<div class="alert alert-warning" role="alert">
Nelson's database is a simple <a href="http://www.h2database.com/">H2</a> file-based datastore. Nelson is intended to be running as a singleton and currently does not support clustering. Support for high-availability deployment modes are planned for a future release, but typically this is not needed as outages of Nelson have no critical affect on the datacenter runtime.
</div>

<h3 id="install-telemetry" class="linkable">Telemetry</h3>

<p>Nelson ships with out of the box support for gathering runtime telemetry with <a href="https://prometheus.io/">Prometheus</a>. The metrics being exported detail all manner of internal details, and are exposed by default on port <code>5775</code> from the JVM process. Here are some of the key metrics:</p>

<table class="table table-striped">
  <thead>
    <tr>
      <td><strong>metric</strong></td>
      <td><strong>description</strong></td>
    </tr>
  </thead>
  <tr>
    <td><code>helm_requests_failures_total</code></td>
    <td>Number of requests that fail when calling Consul</td>
  </tr>
  <tr>
    <td><code>helm_requests_latency_seconds</code></td>
    <td>Latency of requests being sent to Consul</td>
  </tr>
  <tr>
    <td><code>docker_requests_failures_total</code></td>
    <td>Number of requests that fail when calling the Docker Registry</td>
  </tr>
  <tr>
    <td><code>docker_requests_latency_seconds</code></td>
    <td>Latency of requests being sent to the Docker Registry</td>
  </tr>
    <tr>
    <td><code>vault_requests_failures_total</code></td>
    <td>Number of requests that fail when calling Vault</td>
  </tr>
  <tr>
    <td><code>vault_requests_latency_seconds</code></td>
    <td>Latency of requests being sent to Vault</td>
  </tr>
</table>

<p>In addition to these key metrics, there are a variety of general system and JVM metrics that are being exported, and these should also be carefully monitored for issues. Naturally, this goes for any application and not just Nelson.</p>

<h3 id="installation-complete" class="linkable">Installation Complete</h3>

<p>With those steps complete, you should be able to browse to the Nelson URL and login using your Github account. If you encounter problems during this setup process, please check the logs from the Nelson container using <code>journalctl</code> on the host (assuming modern Linux OS with <code>systemd</code>). Alternatively, install any of the generic log forwarding products (splunk, fluentd, logstash etc) to export the logs into an indexed aggregator (this is highly recommended for production usage).</p>

<h2 id="install-auditing" data-subheading-of="operator-guide">Audit Trail</h2>

<p>The Nelson philosophy is a fairly permissive one: provide a tool that allows engineering staff to move fast and iterate quickly, without having to cleanup after themselves and handle some of the most difficult operational details such as mutual TLS. Whilst moving fast is great, it is frequently viewed as a security nightmare, and as such having bomb-proof auditing to know what changed in the system and why is absolutely key.</p>

<p>With this frame, Nelson supports an auditing API that can inform you about everything that Nelson is doing and why. The supplied API is designed to be a building block that you integrate into your wider environment to detect changes in your security and deployment footprint. Please see the <a href="reference.html#api-audit">auditing API documentation for further information</a></p>

<h2 id="install-failure-domains" data-subheading-of="operator-guide">Failure Domains</h2>

<p>To run Nelson you will need access to a target datacenter. One can consider this logical datacenter - in practice - to be a <a href="https://en.wikipedia.org/wiki/Failure_domain">failure domain</a>. Every system should be redundant within the domain, but isolated from other datacenters. Typically Nelson requires the datacenter to be setup with a few key services before it can effectively be used. Imagine the setup with the following components:</p>

<div class="clearing">
  <img src="images/atomic-datacenter.png" />
  <small><em>Figure 4.0: failure domain</em></small>
</div>

<p>Logically, Nelson sits outside one of its target datacenters. This could mean it lives at your office next to your Github, or it might actually reside in one of the target datacenters itself. This is an operational choice that you would make, and provided Nelson has network line of sight to these key services, you can put it wherever you like. With that being said, it is recommended that your stage and runtime docker registries be different, as the performance characteristics of the runtime and staging registries are quite different. Specifically, the runtime registry receives many requests to <code>pull</code> images whilst deploying containers to the cluster, whilst the staging registry largely has mass-writes from your build system. Keeping these separate ensures that either side of that interaction does not fail the other.</p>

<p>Whatever you choose, the rest of this operators guide will assume that you have configured one or more logical datacenters. If you don&rsquo;t want to setup a <em>real</em> datacenter, <a href="https://github.com/timperrett/hashpi">see the authors Github</a> about how to setup a <a href="https://www.raspberrypi.org/">Raspberry PI</a> cluster which can serve as your datacenter.</p>

<h2 id="install-dc-dns" data-subheading-of="operator-guide">Name Resolution</h2>

<p>From an operations perspective, it is important to understand how Nelson is translating its concept of <code>Unit</code>, <code>Stack</code> and <code>Version</code> into runtime DNS naming. Consider these examples:</p>

<ul>
<li><code>accounts--3-1-2--RfgqDc3x.service.dc1.yourcompany.com</code></li>
<li><code>profile--6-3-1--Jd5gv2xq.service.massachusetts.yourtld.com</code></li>
</ul>

<p>In these two examples, the <a href="#user-guide-terminology">stack name</a> has been prefixed to <code>.service.&lt;datacenter&gt;.&lt;top-level-doamin&gt;</code>. Whilst the author heartily recommends you <a href="https://www.consul.io/docs/guides/forwarding.html">read the consul documentation</a> on setting up DNS forwarding, but assuming you have that available and your DNS records do the right delegation you should be able to reference your stacks by a simple DNS convention. The domain that Nelson chooses to use as the TLD for domains is specified by <code>NELSON_DOMAIN</code> when <a href="#install-launching">launching</a> the Nelson container.</p>

<p>Regardless of how ugly the exploded stack names look with their double dashes, this is unfortunately one of the very few schemes that meets the domain name RFC whilst also still enabling users to leverage externally rooted certificate material if needed (the key part here being that your TLD must match the domain you actually own, in order for an externally rooted CA to issue a certificate to you for that domain). As an operator, you could decide that you did not want to use externally rooted material, and perhaps use a scheme like <code>&lt;stack&gt;.service.&lt;dc&gt;.local</code>. This would also work, provided the <code>local</code> TLD was resolvable for all parties (again, this is not recommended, but would work if you wanted / needed it too).</p>

<h2 id="install-manual-deployment" data-subheading-of="operator-guide">Manual Deployments</h2>

<p>Eventually, the time will come such that you must deploy something outside of Nelson - such as a database - but still need to let Nelson know about it in order to have applications depend on it. This is something that has full support and is easily accomplished with the CLI:</p>

<pre><code>$ nelson stacks manual \
  --datacenter california \
  --namespace dev \
  --service-type zookeeper \
  --version 3.4.6 \
  --hash xW3rf6Kq \
  --description &quot;example zookeeper&quot; \
  --port 2181
</code></pre>

<p>In this example, the <code>zookeeper</code> stack was deployed outside of the Nelson-supported scheduler. It is common for such coordination and persistent systems to be deployed outside a dynamic scheduling environment as they are typically very sensitive to network partitions, rebalancing and loss of a cluster member. All that is needed is to simply tell Nelson about the particulars and be aware of the following items when using manual deployments:</p>

<ul>
<li><p>The system in question is part of the Consul mesh and has implemented <a href="#install-dc-dns">DNS setup as mentioned earlier</a>. This typically means the systems will be running Consul agent, configured to talk to the Consul server in that datacenter / domain.</p></li>

<li><p>Nelson will never care about the current state of the target system being added as a manual deployment. It is expected the systems outside of Nelson are monitored and managed out of band. If an operator decides to cleanup the stack that Nelson was informed about, the operator <strong>must</strong> be sure to run <code>nelson stack deprecate &lt;guid&gt;</code> of the manual deployment so that Nelson will remove it from the currently operational stack list.</p></li>

<li><p>Any system that was <strong>deployed with Nelson</strong> should never be added as a manual deployment. This is unnecessary as Nelson is already maintaining its internal routing graph dynamically.</p></li>
</ul>

<p>For the majority of users, manual deployments will be an operational implementation detail, and users will simply depend on these manual deployments just like any other dependency.</p>

<h2 id="ops-credentials" data-subheading-of="operator-guide">Administering Vault</h2>

<p>In order to provide user applications with credentials at runtime, a member of the operations staff must provision a backend in <a href="https://www.vaultproject.io/">Vault</a>. This can either by one of the provided secret backends which generate credentials dynamically, or a generic backend for an arbitrary credential blob. Nelson is using the following convention regarding how it resolves credential paths, from a <code>root</code> of your choosing. The following example assumes <code>myorg</code> is the <code>root</code>:</p>

<pre><code>myorg/&lt;namespace&gt;/&lt;resource&gt;/creds/&lt;unitName&gt;
</code></pre>

<p>The variable parts of this path mean something to Nelson:</p>

<ul>
<li><code>&lt;namespace&gt;</code>: one of <code>dev</code>, <code>qa</code>, <code>prod</code>.</li>
<li><code>&lt;resource&gt;</code>: the name of a resource, like <code>mysql</code></li>
<li><code>&lt;unitName&gt;</code>: the name of the unit being deployed, for example <code>howdy-http</code></li>
</ul>

<p>If a unit does not have access to a resource within a given namespace, the secret will not exist.  All secrets at these paths can be expected to contain fields named <code>username</code> and <code>password</code>. Extended properties depend on the type of <a href="https://www.vaultproject.io/docs/auth/index.html">auth backend</a> holding the secret, so as an operations team member you have a responsibility to ensure that the credentials you are providing are needed, and to engage security team advice if you are not certain about access requirements.</p>

<p>The following are examples of <strong>valid</strong> Nelson-compatible <code>mount</code> paths:</p>

<ul>
<li><code>acmeco/prod/docker-registry</code></li>
<li><code>foobar/dev/s3-yourbucket</code></li>
<li><code>acmeco/prod/accounts-db</code></li>
</ul>

<p>The following are examples of <strong>invalid</strong> <code>mount</code> paths:</p>

<ul>
<li><p><code>acmeco/prod/s3-prod-somebucket</code> - including the namespace name as part of the resource identifier makes it impossible for users to generically write consul-templates against the Vault path.</p></li>

<li><p><code>acmeco/prod/s3-prod-somebucket-california</code> - in addition to the namespace, including a datacenter specific identifier again makes templating problematic, as it breaks Nelson&rsquo;s deploy target transparency&hellip; instead, user a generic path that can have a valid value in all datacenters.</p></li>

<li><p><code>foobar/dev/accounts-db /</code> - the trailing slash causes issues both in Vault and Nelson</p></li>
</ul>

<p>In order to obtain the credentials in your container runtime, it is typically expected that users will leverage <a href="https://github.com/hashicorp/consul-template">consul-template</a> to render their credentials. Consul Template has built in support for extracting credentials from Vault, so the amount of user-facing integration work is very minimal.</p>

<h1 id="community" class="page-header">Community</h1>

<p>The best place to find the developers of Nelson is either the Gitter chat channel or the Nelson mailing list.</p>

<ul>
<li><a href="https://groups.google.com/forum/#!forum/nelson-users">Mailing list</a></li>
<li><a href="https://gitter.im/Verizon/nelson">Gitter</a></li>
</ul>

<p>If there are security issues you find with Nelson, please reach out to the team directly, and we will work with you on providing a fix into the project before announcing it publicly.</p>

<h2 id="community-contributing" data-subheading-of="community">Contributing</h2>

<p>Contributing to Nelson is straight forward! If there is something you think needs to be fixed, either open an issue on GitHub or - better yet - just send a pull request with a patch. Typically speaking we are diligent about backward compatibility, both in the API and in the YAML specifications. Nelson can support breaking changes, but in doing so we have to coordinate upgrades to the command line client and the existing user base.</p>

<p>Any contributions you make to Nelson must be wholly owned by you, and we cannot accept any contributions that contain material that is not compatible with the Apache 2.0 license.</p>

<h1 id="credits" class="page-header">Credits</h1>

<p>Building Nelson was a multi-month effort by the Verizon Labs Infrastructure Engineering team. In addition to the specific engineers called out below, thanks to the other engineering staff internally who provided their useful feedback, advice and tolerance for early-adopter pain.</p>

<h2 id="team" data-subheading-of="credits">Team</h2>

<p>The engineering staff who originally created Nelson are listed below (in order of duration on the project):</p>

<ul>
<li><a href="https://github.com/timperrett">Timothy Perrett</a></li>
<li><a href="https://github.com/stew">Stew O&rsquo;Connor</a></li>
<li><a href="https://github.com/kaiserpelagic">Greg Flanagan</a></li>
<li><a href="https://github.com/rossabaker">Ross A. Baker</a></li>
<li><a href="https://github.com/ceedubs">Cody Allen</a></li>
<li><a href="https://github.com/andrewmohrland">Andrew Morhland</a></li>
<li><a href="https://github.com/berkeleybear">Alice Wu</a></li>
<li><a href="https://github.com/ryanonsrc">Ryan Delucchi</a></li>
</ul>

<p>Finally, the engineering team would like to shout out to the following teams at Verizon who helped make this project happen:</p>

<ul>
<li>Verizon executive management - specifically Suri Medapati - for believing in us, and affording the time for Nelson to be built.</li>
<li>Verizon Legal for providing us the opportunity to release Nelson into the open.</li>
<li>Verizon DevOps for handling all the storage and database systems.</li>
<li>Verizon Network engineering for always connecting us.</li>
</ul>

<h2 id="etymology" data-subheading-of="credits">Etymology</h2>

<p><a href="https://en.wikipedia.org/wiki/Horatio_Nelson,_1st_Viscount_Nelson">Admiral Nelson</a> was a famous British naval commander who fought off foreign advances during the Napoleonic Wars - most notably at the Battle of Trafalgar, as commander of <a href="https://en.wikipedia.org/wiki/HMS_Victory">HMS Victory</a>, where he defeated the French navy despite being outnumbered and outgunned.</p>

          

        </article>
      </div>
      
      <div class="col-md-3" role="complementary">
  <div class="bs-docs-sidebar hidden-print">
    <ul class="nav bs-docs-sidenav">
    </ul>
    <a class="back-to-top" href="#top">
      <i class="glyphicon glyphicon-chevron-up"></i> Back to top
    </a>
  </div>
</div>

    </div>
  </div>

  <footer class="bs-docs-footer" role="contentinfo">
  <div class="container">
    <p>
      Built with &hearts; by the infrastructure engineering team.</p>
    <p>
      Documentation template by <a target="_blank" href="http://getbootstrap.com">Bootstrap team</a>,
      adapted for use with <a target="_blank" href="https://gohugo.com">Hugo.</a>
    </p>

    <ul class="bs-docs-footer-links muted">
      <li>Currently v0.10.48</li>
    
      <li>&middot;</li>
      <li><a href="https://github.com/getnelson/nelson">GitHub</a></li>
    
      <li>&middot;</li>
      <li><a href="https://getnelson.github.io/nelson/issues">Issues</a></li>
    
      <li>&middot;</li>
      <li><a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache 2.0</a></li>
    </ul>
  </div>
</footer>


<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.4.11/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/trianglify/0.1.2/trianglify.min.js"></script>



  <script>trianglify('#041F33', '#3772AD');</script>


<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-57263411-7', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
